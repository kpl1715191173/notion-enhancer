import { __assign, __awaiter, __extends, __generator, __values } from "tslib";
import { Transports } from '@sentry/node';
import { Status } from '@sentry/types';
import { parseRetryAfterHeader, PromiseBuffer, SentryError, timestampWithMs } from '@sentry/utils';
import { net } from 'electron';
import { Readable } from 'stream';
import * as url from 'url';
import { createGzip } from 'zlib';
import { isAppReady } from '../backend';
// Estimated maximum size for reasonable standalone event
var GZIP_THRESHOLD = 1024 * 32;
/**
 * Gets a stream from a Buffer or string
 * We don't have Readable.from in earlier versions of node
 */
function streamFromBody(body) {
    return new Readable({
        read: function () {
            this.push(body);
            this.push(null);
        },
    });
}
/** Using net module of electron */
var NetTransport = /** @class */ (function (_super) {
    __extends(NetTransport, _super);
    /** Create a new instance and set this.agent */
    function NetTransport(options) {
        var _this = _super.call(this, options) || this;
        _this.options = options;
        /** A simple buffer holding all requests. */
        _this._buffer = new PromiseBuffer(30);
        /** Locks transport after receiving 429 response */
        _this._rateLimits = {};
        return _this;
    }
    /**
     * @inheritDoc
     */
    NetTransport.prototype.sendEvent = function (event) {
        return __awaiter(this, void 0, void 0, function () {
            var envelopeHeaders, type, itemHeaders, eventPayload, bodyBuffer;
            return __generator(this, function (_a) {
                envelopeHeaders = JSON.stringify({
                    event_id: event.event_id,
                    // Internal helper that uses `perf_hooks` to get clock reading
                    sent_at: new Date(timestampWithMs() * 1000).toISOString(),
                });
                type = event.type === 'transaction' ? 'transaction' : 'event';
                itemHeaders = JSON.stringify({
                    content_type: 'application/json',
                    // Internal helper that uses `perf_hooks` to get clock reading
                    type: event.type === 'transaction' ? 'transaction' : 'event',
                });
                if (this.isRateLimited(type)) {
                    return [2 /*return*/, Promise.reject(new SentryError("Transport locked till " + JSON.stringify(this._rateLimits, null, 2) + " due to too many requests."))];
                }
                eventPayload = JSON.stringify(event);
                bodyBuffer = Buffer.from(envelopeHeaders + "\n" + itemHeaders + "\n" + eventPayload + "\n");
                return [2 /*return*/, this.sendRequest({
                        body: bodyBuffer,
                        url: this._api.getEnvelopeEndpointWithUrlEncodedAuth(),
                        type: type,
                    })];
            });
        });
    };
    /**
     * Checks if a category is ratelimited
     */
    NetTransport.prototype.isRateLimited = function (category) {
        var disabledUntil = this._rateLimits[category] || this._rateLimits.all;
        // tslint:disable-next-line
        if (new Date(Date.now()) < disabledUntil) {
            return true;
        }
        return false;
    };
    /**
     * Dispatches a Request to Sentry. Only handles SentryRequest
     */
    NetTransport.prototype.sendRequest = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var options, bodyStream;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._buffer.isReady()) {
                            return [2 /*return*/, Promise.reject(new SentryError('Not adding Promise due to buffer limit reached.'))];
                        }
                        return [4 /*yield*/, isAppReady()];
                    case 1:
                        _a.sent();
                        options = this._getRequestOptions(new url.URL(request.url));
                        options.headers = __assign(__assign({}, options.headers), { 'Content-Type': 'application/x-sentry-envelope' });
                        bodyStream = streamFromBody(request.body);
                        if (request.body.length > GZIP_THRESHOLD) {
                            options.headers['Content-Encoding'] = 'gzip';
                            bodyStream = bodyStream.pipe(createGzip());
                        }
                        return [2 /*return*/, this._buffer.add(new Promise(function (resolve, reject) {
                                var req = net.request(options);
                                req.on('error', reject);
                                req.on('response', function (res) {
                                    var status = Status.fromHttpCode(res.statusCode);
                                    if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
                                        resolve({ status: status });
                                    }
                                    else {
                                        if (status === Status.RateLimit) {
                                            _this._handleRateLimit(res.headers);
                                        }
                                        // tslint:disable:no-unsafe-any
                                        if (res.headers && res.headers['x-sentry-error']) {
                                            var reason = res.headers['x-sentry-error'];
                                            if (Array.isArray(reason)) {
                                                reason = reason.join(', ');
                                            }
                                            // tslint:enable:no-unsafe-any
                                            reject(new SentryError("HTTP Error (" + res.statusCode + "): " + reason));
                                        }
                                        else {
                                            reject(new SentryError("HTTP Error (" + res.statusCode + ")"));
                                        }
                                    }
                                    // force the socket to drain
                                    res.on('data', function () {
                                        // Drain
                                    });
                                    res.on('end', function () {
                                        // Drain
                                    });
                                });
                                // The docs say that ClientRequest is Writable but the types don't match exactly
                                bodyStream.pipe(req);
                            }))];
                }
            });
        });
    };
    /**
     * Sets internal _rateLimits from incoming headers
     */
    NetTransport.prototype._handleRateLimit = function (headers) {
        var e_1, _a, e_2, _b, e_3, _c;
        this._rateLimits = {};
        var now = Date.now();
        if (headers['x-sentry-rate-limits']) {
            var rateLimitHeader = Array.isArray(headers['x-sentry-rate-limits'])
                ? headers['x-sentry-rate-limits'][0]
                : headers['x-sentry-rate-limits'];
            rateLimitHeader = rateLimitHeader.trim();
            var quotas = rateLimitHeader.split(',');
            var preRateLimits = {};
            try {
                for (var quotas_1 = __values(quotas), quotas_1_1 = quotas_1.next(); !quotas_1_1.done; quotas_1_1 = quotas_1.next()) {
                    var quota = quotas_1_1.value;
                    var parameters = quota.split(':');
                    var headerDelay = parseInt("" + parameters[0], 10);
                    var delay = 60 * 1000; // 60secs default
                    if (!isNaN(headerDelay)) {
                        // so it is a number ^^
                        delay = headerDelay * 1000; // to have time in secs
                    }
                    var categories = parameters[1].split(';');
                    if (categories.length === 1 && categories[0] === '') {
                        preRateLimits.all = delay;
                    }
                    else {
                        try {
                            for (var categories_1 = (e_2 = void 0, __values(categories)), categories_1_1 = categories_1.next(); !categories_1_1.done; categories_1_1 = categories_1.next()) {
                                var category = categories_1_1.value;
                                preRateLimits[category] = Math.max(preRateLimits[category] || 0, delay);
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (categories_1_1 && !categories_1_1.done && (_b = categories_1.return)) _b.call(categories_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (quotas_1_1 && !quotas_1_1.done && (_a = quotas_1.return)) _a.call(quotas_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            try {
                for (var _d = __values(Object.keys(preRateLimits)), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var key = _e.value;
                    this._rateLimits[key] = new Date(now + preRateLimits[key]);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        else if (headers['retry-after']) {
            var retryAfterHeader = Array.isArray(headers['retry-after'])
                ? headers['retry-after'][0]
                : headers['retry-after'];
            this._rateLimits.all = new Date(now + parseRetryAfterHeader(now, retryAfterHeader));
        }
    };
    return NetTransport;
}(Transports.BaseTransport));
export { NetTransport };
//# sourceMappingURL=net.js.map