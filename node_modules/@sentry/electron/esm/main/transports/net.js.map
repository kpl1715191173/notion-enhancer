{"version":3,"file":"net.js","sourceRoot":"","sources":["../../../src/main/transports/net.ts"],"names":[],"mappings":"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","sourcesContent":["import { Transports } from '@sentry/node';\nimport { Event, Response, SentryRequest, Status, TransportOptions } from '@sentry/types';\nimport { parseRetryAfterHeader, PromiseBuffer, SentryError, timestampWithMs } from '@sentry/utils';\nimport { net } from 'electron';\nimport { Readable, Writable } from 'stream';\nimport * as url from 'url';\nimport { createGzip } from 'zlib';\n\nimport { isAppReady } from '../backend';\n\n// Estimated maximum size for reasonable standalone event\nconst GZIP_THRESHOLD = 1024 * 32;\n\n/**\n * SentryElectronRequest\n */\nexport interface SentryElectronRequest extends Omit<SentryRequest, 'body'> {\n  body: string | Buffer;\n}\n\n/**\n * Gets a stream from a Buffer or string\n * We don't have Readable.from in earlier versions of node\n */\nfunction streamFromBody(body: Buffer | string): Readable {\n  return new Readable({\n    read() {\n      this.push(body);\n      this.push(null);\n    },\n  });\n}\n\n/** Using net module of electron */\nexport class NetTransport extends Transports.BaseTransport {\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<Response> = new PromiseBuffer(30);\n\n  /** Locks transport after receiving 429 response */\n  private _rateLimits: Record<string, Date> = {};\n\n  /** Create a new instance and set this.agent */\n  public constructor(public options: TransportOptions) {\n    super(options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async sendEvent(event: Event): Promise<Response> {\n    const envelopeHeaders = JSON.stringify({\n      event_id: event.event_id,\n      // Internal helper that uses `perf_hooks` to get clock reading\n      sent_at: new Date(timestampWithMs() * 1000).toISOString(),\n    });\n    const type = event.type === 'transaction' ? 'transaction' : 'event';\n    const itemHeaders = JSON.stringify({\n      content_type: 'application/json',\n      // Internal helper that uses `perf_hooks` to get clock reading\n      type: event.type === 'transaction' ? 'transaction' : 'event',\n    });\n\n    if (this.isRateLimited(type)) {\n      return Promise.reject(\n        new SentryError(`Transport locked till ${JSON.stringify(this._rateLimits, null, 2)} due to too many requests.`),\n      );\n    }\n\n    const eventPayload = JSON.stringify(event);\n    const bodyBuffer = Buffer.from(`${envelopeHeaders}\\n${itemHeaders}\\n${eventPayload}\\n`);\n\n    return this.sendRequest({\n      body: bodyBuffer,\n      url: this._api.getEnvelopeEndpointWithUrlEncodedAuth(),\n      type,\n    });\n  }\n\n  /**\n   * Checks if a category is ratelimited\n   */\n  public isRateLimited(category: string): boolean {\n    const disabledUntil = this._rateLimits[category] || this._rateLimits.all;\n    // tslint:disable-next-line\n    if (new Date(Date.now()) < disabledUntil) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Dispatches a Request to Sentry. Only handles SentryRequest\n   */\n  public async sendRequest(request: SentryElectronRequest): Promise<Response> {\n    if (!this._buffer.isReady()) {\n      return Promise.reject(new SentryError('Not adding Promise due to buffer limit reached.'));\n    }\n\n    await isAppReady();\n\n    const options = this._getRequestOptions(new url.URL(request.url));\n    options.headers = {\n      ...options.headers,\n      'Content-Type': 'application/x-sentry-envelope',\n    };\n\n    let bodyStream = streamFromBody(request.body);\n\n    if (request.body.length > GZIP_THRESHOLD) {\n      options.headers['Content-Encoding'] = 'gzip';\n      bodyStream = bodyStream.pipe(createGzip());\n    }\n\n    return this._buffer.add(\n      new Promise<Response>((resolve, reject) => {\n        const req = net.request(options as Electron.ClientRequestConstructorOptions);\n        req.on('error', reject);\n        req.on('response', (res: Electron.IncomingMessage) => {\n          const status = Status.fromHttpCode(res.statusCode);\n          if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {\n            resolve({ status });\n          } else {\n            if (status === Status.RateLimit) {\n              this._handleRateLimit(res.headers);\n            }\n\n            // tslint:disable:no-unsafe-any\n            if (res.headers && res.headers['x-sentry-error']) {\n              let reason: string | string[] = res.headers['x-sentry-error'];\n              if (Array.isArray(reason)) {\n                reason = reason.join(', ');\n              }\n              // tslint:enable:no-unsafe-any\n              reject(new SentryError(`HTTP Error (${res.statusCode}): ${reason}`));\n            } else {\n              reject(new SentryError(`HTTP Error (${res.statusCode})`));\n            }\n          }\n          // force the socket to drain\n          res.on('data', () => {\n            // Drain\n          });\n          res.on('end', () => {\n            // Drain\n          });\n        });\n\n        // The docs say that ClientRequest is Writable but the types don't match exactly\n        bodyStream.pipe((req as any) as Writable);\n      }),\n    );\n  }\n\n  /**\n   * Sets internal _rateLimits from incoming headers\n   */\n  private _handleRateLimit(headers: Record<string, string[] | string>): void {\n    this._rateLimits = {};\n    const now = Date.now();\n    if (headers['x-sentry-rate-limits']) {\n      let rateLimitHeader = Array.isArray(headers['x-sentry-rate-limits'])\n        ? headers['x-sentry-rate-limits'][0]\n        : headers['x-sentry-rate-limits'];\n      rateLimitHeader = rateLimitHeader.trim();\n      const quotas = rateLimitHeader.split(',');\n      const preRateLimits: Record<string, number> = {};\n      for (const quota of quotas) {\n        const parameters = quota.split(':');\n        const headerDelay = parseInt(`${parameters[0]}`, 10);\n        let delay = 60 * 1000; // 60secs default\n        if (!isNaN(headerDelay)) {\n          // so it is a number ^^\n          delay = headerDelay * 1000; // to have time in secs\n        }\n        const categories = parameters[1].split(';');\n        if (categories.length === 1 && categories[0] === '') {\n          preRateLimits.all = delay;\n        } else {\n          for (const category of categories) {\n            preRateLimits[category] = Math.max(preRateLimits[category] || 0, delay);\n          }\n        }\n      }\n      for (const key of Object.keys(preRateLimits)) {\n        this._rateLimits[key] = new Date(now + preRateLimits[key]);\n      }\n    } else if (headers['retry-after']) {\n      const retryAfterHeader = Array.isArray(headers['retry-after'])\n        ? headers['retry-after'][0]\n        : headers['retry-after'];\n\n      this._rateLimits.all = new Date(now + parseRetryAfterHeader(now, retryAfterHeader));\n    }\n  }\n}\n"]}