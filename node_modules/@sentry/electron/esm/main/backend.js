import { __assign, __awaiter, __extends, __generator } from "tslib";
/* eslint-disable max-lines */
import { addBreadcrumb, BaseBackend, captureEvent, captureMessage, configureScope, getCurrentHub, Scope, } from '@sentry/core';
import { NodeBackend } from '@sentry/node';
import { Severity } from '@sentry/types';
import { Dsn, forget, logger, SentryError } from '@sentry/utils';
import { app, crashReporter, ipcMain } from 'electron';
import { join } from 'path';
import { getNameFallback, IPC_EVENT, IPC_PING, IPC_SCOPE } from '../common';
import { supportsGetPathCrashDumps, supportsRenderProcessGone } from '../electron-version';
import { captureMinidump } from './index';
import { normalizeUrl } from './normalize';
import { Store } from './store';
import { NetTransport } from './transports/net';
import { MinidumpUploader } from './uploader';
/** Gets the path to the Sentry cache directory. */
function getCachePath() {
    return join(app.getPath('userData'), 'sentry');
}
/**
 * Retruns a promise that resolves when app is ready.
 */
export function isAppReady() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, (app.isReady() ||
                    new Promise(function (resolve) {
                        app.once('ready', function () {
                            resolve(true);
                        });
                    }))];
        });
    });
}
/** Backend implementation for Electron renderer backends. */
var MainBackend = /** @class */ (function (_super) {
    __extends(MainBackend, _super);
    /** Creates a new Electron backend instance. */
    function MainBackend(options) {
        var _this = _super.call(this, options) || this;
        _this._inner = new NodeBackend(options);
        _this._scopeStore = new Store(getCachePath(), 'scope_v2', new Scope());
        // We need to store the scope in a variable here so it can be attached to minidumps
        _this._scopeLastRun = _this._scopeStore.get();
        _this._setupScopeListener();
        if (_this._isNativeEnabled()) {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            forget(_this._installNativeHandler());
        }
        _this._installIPC();
        return _this;
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    MainBackend.prototype.eventFromException = function (exception, hint) {
        return this._inner.eventFromException(exception, hint);
    };
    /**
     * @inheritDoc
     */
    MainBackend.prototype.eventFromMessage = function (message, level, hint) {
        if (level === void 0) { level = Severity.Info; }
        return this._inner.eventFromMessage(message, level, hint);
    };
    /**
     * @inheritDoc
     */
    MainBackend.prototype.sendEvent = function (event) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        if (event.__INTERNAL_MINIDUMP) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            delete event.__INTERNAL_MINIDUMP;
            delete event.event_id;
            crashReporter.addExtraParameter('sentry', JSON.stringify(event));
        }
        else {
            this._inner.sendEvent(event);
        }
        // eslint-enable @typescript-eslint/no-unsafe-member-access
    };
    /**
     * Uploads the given minidump and attaches event information.
     *
     * @param path A relative or absolute path to the minidump file.
     * @param event Optional event information to add to the minidump request.
     */
    MainBackend.prototype.uploadMinidump = function (path, event) {
        if (event === void 0) { event = {}; }
        if (this._uploader) {
            forget(this._uploader.uploadMinidump({ path: path, event: event }));
        }
    };
    /**
     * Setup Transport
     */
    MainBackend.prototype._setupTransport = function () {
        if (!this._options.dsn) {
            // We return the noop transport here in case there is no Dsn.
            return _super.prototype._setupTransport.call(this);
        }
        var transportOptions = __assign(__assign(__assign(__assign(__assign({}, this._options.transportOptions), (this._options.httpProxy && { httpProxy: this._options.httpProxy })), (this._options.httpsProxy && { httpsProxy: this._options.httpsProxy })), (this._options.caCerts && { caCerts: this._options.caCerts })), { dsn: this._options.dsn });
        if (this._options.transport) {
            return new this._options.transport(transportOptions);
        }
        return new NetTransport(transportOptions);
    };
    /**
     * Adds a scope listener to persist changes to disk.
     */
    MainBackend.prototype._setupScopeListener = function () {
        var _this = this;
        var hubScope = getCurrentHub().getScope();
        if (hubScope) {
            hubScope.addScopeListener(function (updatedScope) {
                var cloned = Scope.clone(updatedScope);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                cloned._eventProcessors = [];
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                cloned._scopeListeners = [];
                // if we use the crashpad minidump uploader we have to set extra whenever the scope updates
                if (_this._options.useCrashpadMinidumpUploader === true) {
                    getCurrentHub().captureEvent({
                        // @ts-ignore __INTERNAL_MINIDUMP is not assignable to event
                        __INTERNAL_MINIDUMP: true,
                    }, {
                        data: {
                            __sentry__: true,
                        },
                    });
                }
                _this._scopeStore.set(cloned);
            });
        }
    };
    /** Returns whether native reports are enabled. */
    MainBackend.prototype._isNativeEnabled = function () {
        // Mac AppStore builds cannot run the crash reporter due to the sandboxing
        // requirements. In this case, we prevent enabling native crashes entirely.
        // https://electronjs.org/docs/tutorial/mac-app-store-submission-guide#limitations-of-mas-build
        if (process.mas) {
            return false;
        }
        return this._options.enableNative !== false;
    };
    /** Activates the Electron CrashReporter. */
    MainBackend.prototype._installNativeHandler = function () {
        return __awaiter(this, void 0, void 0, function () {
            var dsnString, dsn, crashesDirectory, sendRendererCrash;
            var _this = this;
            return __generator(this, function (_a) {
                dsnString = this._options.dsn;
                if (!dsnString) {
                    throw new SentryError('Attempted to enable Electron native crash reporter but no DSN was supplied');
                }
                dsn = new Dsn(dsnString);
                // We will manually submit errors, but CrashReporter requires a submitURL in
                // some versions. Also, provide a productName and companyName, which we will
                // add manually to the event's context during submission.
                crashReporter.start({
                    companyName: '',
                    ignoreSystemCrashHandler: true,
                    productName: this._options.appName || getNameFallback(),
                    submitURL: MinidumpUploader.minidumpUrlFromDsn(dsn),
                    uploadToServer: this._options.useCrashpadMinidumpUploader || false,
                    compress: true,
                });
                if (this._options.useSentryMinidumpUploader !== false) {
                    crashesDirectory = supportsGetPathCrashDumps()
                        ? app.getPath('crashDumps')
                        : // unsafe member access required because of older versions of Electron
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                            crashReporter.getCrashesDirectory();
                    this._uploader = new MinidumpUploader(dsn, crashesDirectory, getCachePath(), this.getTransport());
                    // Flush already cached minidumps from the queue.
                    forget(this._uploader.flushQueue());
                    // Start to submit recent minidump crashes. This will load breadcrumbs and
                    // context information that was cached on disk prior to the crash.
                    forget(this._sendNativeCrashes({}));
                }
                sendRendererCrash = function (contents, details) { return __awaiter(_this, void 0, void 0, function () {
                    var e_1;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, this._sendNativeCrashes(this._getNewEventWithElectronContext(contents, details))];
                            case 1:
                                _a.sent();
                                return [3 /*break*/, 3];
                            case 2:
                                e_1 = _a.sent();
                                // eslint-disable-next-line no-console
                                console.error(e_1);
                                return [3 /*break*/, 3];
                            case 3:
                                addBreadcrumb({
                                    category: 'exception',
                                    level: Severity.Critical,
                                    message: 'Renderer Crashed',
                                });
                                return [2 /*return*/];
                        }
                    });
                }); };
                // Every time a subprocess or renderer crashes, start sending minidumps
                // right away.
                app.on('web-contents-created', function (_, contents) {
                    if (supportsRenderProcessGone()) {
                        contents.on('render-process-gone', function (_event, details) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, sendRendererCrash(contents, details)];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                    }
                    else {
                        // unsafe member access required because of older versions of Electron
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                        contents.on('crashed', function () { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, sendRendererCrash(contents)];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                    }
                    if (_this._options.enableUnresponsive !== false) {
                        contents.on('unresponsive', function () {
                            captureMessage('BrowserWindow Unresponsive');
                        });
                    }
                });
                return [2 /*return*/];
            });
        });
    };
    /** Installs IPC handlers to receive events and metadata from renderers. */
    MainBackend.prototype._installIPC = function () {
        var _this = this;
        ipcMain.on(IPC_PING, function (event) {
            event.sender.send(IPC_PING);
        });
        ipcMain.on(IPC_EVENT, function (ipc, jsonEvent) {
            var event;
            try {
                event = JSON.parse(jsonEvent);
            }
            catch (_a) {
                // eslint-disable-next-line no-console
                console.warn('sentry-electron received an invalid IPC_EVENT message');
                return;
            }
            event.contexts = __assign(__assign({}, _this._getNewEventWithElectronContext(ipc.sender).contexts), event.contexts);
            captureEvent(event);
        });
        ipcMain.on(IPC_SCOPE, function (_, jsonRendererScope) {
            var rendererScope;
            try {
                rendererScope = JSON.parse(jsonRendererScope);
            }
            catch (_a) {
                // eslint-disable-next-line no-console
                console.warn('sentry-electron received an invalid IPC_SCOPE message');
                return;
            }
            var sentScope = Scope.clone(rendererScope);
            /* eslint-disable @typescript-eslint/no-unsafe-member-access */
            configureScope(function (scope) {
                if (sentScope._user) {
                    scope.setUser(sentScope._user);
                }
                scope.setTags(sentScope._tags);
                scope.setExtras(sentScope._extra);
                // Since we do not have updates for individual breadcrumbs anymore and only for the whole scope
                // we just add the last added breadcrumb on scope updates
                scope.addBreadcrumb(sentScope._breadcrumbs.pop());
            });
            /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        });
    };
    /** Loads new native crashes from disk and sends them to Sentry. */
    MainBackend.prototype._sendNativeCrashes = function (event) {
        return __awaiter(this, void 0, void 0, function () {
            var uploader, paths, currentCloned, storedScope, newEvent_1, _oO_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Whenever we are called, assume that the crashes we are going to load down
                        // below have occurred recently. This means, we can use the same event data
                        // for all minidumps that we load now. There are two conditions:
                        //
                        //  1. The application crashed and we are just starting up. The stored
                        //     breadcrumbs and context reflect the state during the application
                        //     crash.
                        //
                        //  2. A renderer process crashed recently and we have just been notified
                        //     about it. Just use the breadcrumbs and context information we have
                        //     right now and hope that the delay was not too long.
                        if (this._options.useSentryMinidumpUploader === false) {
                            // In case we are not using the Sentry Minidump uploader we don't want to throw an error
                            return [2 /*return*/];
                        }
                        uploader = this._uploader;
                        if (uploader === undefined) {
                            throw new SentryError('Invariant violation: Native crashes not enabled');
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 7, , 8]);
                        return [4 /*yield*/, uploader.getNewMinidumps()];
                    case 2:
                        paths = _a.sent();
                        if (!(paths.length > 0)) return [3 /*break*/, 6];
                        currentCloned = Scope.clone(getCurrentHub().getScope());
                        storedScope = Scope.clone(this._scopeLastRun);
                        return [4 /*yield*/, storedScope.applyToEvent(event)];
                    case 3:
                        newEvent_1 = _a.sent();
                        if (!newEvent_1) return [3 /*break*/, 5];
                        return [4 /*yield*/, currentCloned.applyToEvent(newEvent_1)];
                    case 4:
                        newEvent_1 = _a.sent();
                        paths.map(function (path) {
                            captureMinidump(path, __assign({}, newEvent_1));
                        });
                        _a.label = 5;
                    case 5:
                        // Unset to recover memory
                        this._scopeLastRun = undefined;
                        _a.label = 6;
                    case 6: return [3 /*break*/, 8];
                    case 7:
                        _oO_1 = _a.sent();
                        logger.error('Error while sending native crash.');
                        return [3 /*break*/, 8];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /** Returns extra information from a renderer's web contents. */
    MainBackend.prototype._getNewEventWithElectronContext = function (contents, details) {
        var customName = this._options.getRendererName && this._options.getRendererName(contents);
        var electronContext = {
            crashed_process: customName || "renderer[" + contents.id + "]",
            crashed_url: normalizeUrl(contents.getURL()),
        };
        if (details) {
            // We need to do it like this, otherwise we normalize undefined to "[undefined]" in the UI
            electronContext.details = details;
        }
        return {
            contexts: {
                electron: electronContext,
            },
        };
    };
    return MainBackend;
}(BaseBackend));
export { MainBackend };
//# sourceMappingURL=backend.js.map